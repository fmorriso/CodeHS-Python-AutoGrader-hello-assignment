class Suite(PythonTestSuite):
    
    # Any values that should be passed to any call to `input`
    inputs = ["Mark"]

    # Write any tests that should run before the code is evaluated
    def before_run(self, student_code, solution_code):
        
        code_lower = strip_comments(student_code).lower()
 """         
        # verify there is a def statement
        idx_def = code_lower.find('def ')
        expect(idx_def).to_be_greater_than_or_equal_to(0) \
            .with_options(test_name="contains def")
         
        # verify def is followed by hello
        if idx_def > 0:
            
            # verify the function is named hello (case sensitive)
            idx_fn_name = code_lower[idx_def:].find('hello')
            expect(idx_fn_name).to_be_greater_than(0) \
                .with_options(test_name='contains function named hello (all lower case)')
                
            
            # verify the function passes in a parameter called name in parens
            if idx_fn_name >= 0:
                idx_left_paren = code_lower[idx_fn_name:].find('(')
                if idx_left_paren >= 0:
                    idx_param = code_lower[idx_left_paren].find('name')
                    expect(idx_fn_name).to_be_greater_than(0) \
                        .with_options(test_name='hello function expects a name parameter')
                       
                # verify the hello function contains a return statement
                # TODO: this has stopped working as of 2023-12-16 and I do not know why
                idx_return = code_lower[idx_fn_name:].find('return')
                expect(idx_return).to_be_greater_than(0) \
                    .with_options(test_name='hello function contains return statement')
             
            # verify that return is followed by the literal string hello (case insensitive)
            if idx_return > 0:
                idx_hello = code_lower[idx_return:].find('hello, ')
                expect(idx_hello).to_be_greater_than(0) \
                    .with_options(test_name='hello function returns hello with comma in quotes')
                    
                # verify that "hello, " or 'hello, ' is followed by the + sign operator
                if idx_hello > 0:
                    idx_plus_sign = code_lower[idx_hello:].find('+')
                    expect(idx_plus_sign).to_be_greater_than(0) \
                        .with_options(test_name='hello function return statement contains plus operator')
                        
                    # verify + is followed by the name parameter
                    if idx_plus_sign > 0:
                        idx_name_param = code_lower[idx_plus_sign:].find('name')
                        expect(idx_name_param).to_be_greater_than(0) \
                            .with_options(test_name=f'hello function return statement concatenates name parameter {code_lower(idx_name_param)}')
                            
                        # verify that name is NOT surrounded by " or ' characters - WARNING: indexes are relative to last find !!!
                        # THIS PART IS BROKEN AND I DO NOT KNOW HOW TO FIX IT
                        code_beyond_last_find = code_lower[idx_plus_sign:]
                        possible_quote_char = code_beyond_last_find[idx_name_param -1 : idx_name_param]
                        expect(possible_quote_char).not_to_contain('"') \
                            .with_options(test_name=f'{possible_quote_char} name parameter is NOT surrounded by quote characters')
                        
            
   
        # make sure the user prompts for input
        idx_input = student_code.find('input')
        expect(idx_input).to_be_greater_than(0) \
            .with_options(test_name='contains input statement')
        if idx_input >= 0:
            # locate the left paren
            idx_left_paren = student_code[idx_input:].find('(')
            expect(idx_left_paren).to_be_greater_than(0) \
                .with_options(test_name='input statement contains left paren')
            # verify there is some kind of quoted string in the input statement after the left paren
            if idx_left_paren >= 0:
                # assume the student uses double-quotes until proven otherwise
                type_of_quote = '"'
                idx_quote_start = student_code[idx_left_paren:].find('"')
                # might be using single quotes
                if idx_quote_start < 0:
                    idx_quote_start = student_code[idx_left_paren:].find("'")
                    if idx_quote_start >= 0:
                        type_of_quote = "'"
                expect(idx_quote_start).to_be_greater_than(0) \
                        .with_options(test_name='input statement contains a starting quote character')
                        
                # look for the matching ending quote
                if idx_quote_start >= 0:
                    idx_quote_end = student_code[idx_quote_start+1:].find(type_of_quote)
                    expect(idx_quote_end).to_be_greater_than(0) \
                        .with_options(test_name='input statement contains a matching ending quote character')
        
                # check for closing right paren at the end of the input statemtn
                if idx_quote_start > 0 and idx_quote_end > 0:
                    idx_right_paren = student_code[idx_quote_end:].find(')')
                    expect(idx_quote_end).to_be_greater_than(0) \
                        .with_options(test_name='input statement contains a matching right paren')
        


        #pass
"""        

    # Write any tests that should run after the code is evaluated
    def after_run(self, student_code, solution_code, student_output, solution_output):
        
        student_lower = student_output.lower()
        solution_lower = solution_output.lower()
        
        idx_hello = student_lower.find('hello,')
        expect(idx_hello).to_be_greater_than_or_equal_to(0) \
            .with_options(test_name='output contains hello, or Hello, ')
                

Suite()
