class Suite(PythonTestSuite):
    
    # Any values that should be passed to any call to `input`
    inputs = ["Mark"]

    # Write any tests that should run before the code is evaluated
    def before_run(self, student_code, solution_code):
        
        code_lower = student_code.lower()
        
        # verify there is a def statement
        idx_def = student_code.find('def ')
        expect(idx_def).to_be_greater_than_or_equal_to(0) \
            .with_options(test_name="contains def")
        
        # verify def is followed by hello
        if idx_def > 0:
            
            # verify the function is named hello (case sensitive)
            idx_fn_name = student_code[idx_def:].find('hello')
            expect(idx_fn_name).to_be_greater_than(0) \
                .with_options(test_name='contains function named hello (all lower case)')
                
            
            # verify the function passes in a parameter called name in parens
            if idx_fn_name >= 0:
                idx_left_paren = student_code[idx_fn_name:].find('(')
                if idx_left_paren >= 0:
                    idx_param = student_code[idx_left_paren].find('name')
                    expect(idx_fn_name).to_be_greater_than(0) \
                        .with_options(test_name='hello function expects a name parameter')
                       
            # verify the hello function contains a return statement
            idx_return = code_lower[idx_def:].find('return ')
            expect(idx_return).to_be_greater_than(0) \
                .with_options(test_name='hello function contains return statement')
                
            # verify that return is followed by the literal string hello (case insensitive)
            if idx_return > 0:
                idx_hello = code_lower[idx_return:].find('hello, ')
                expect(idx_hello).to_be_greater_than(0) \
                    .with_options(test_name='hello function returns hello with comma in quotes')
                    
                # verify that "hello, " or 'hello, ' is followed by the + sign operator
                if idx_hello > 0:
                    idx_plus_sign = code_lower[idx_hello:].find('+')
                    expect(idx_plus_sign).to_be_greater_than(0) \
                        .with_options(test_name='hello function return statement contains plus operator')
                        
                    # verify + is followed by the name parameter
                    if idx_plus_sign > 0:
                        idx_name_param = code_lower[idx_plus_sign:].find('name')
                        expect(idx_name_param).to_be_greater_than(0) \
                            .with_options(test_name='hello function return statement concatenates name parameter')
            
   
        # make sure the user prompts for input
        idx_input = student_code.find('input')
        expect(idx_input).to_be_greater_than(0) \
            .with_options(test_name='contains input statement')
        if idx_input >= 0:
            # locate the left paren
            idx_left_paren = student_code[idx_input:].find('(')
            expect(idx_left_paren).to_be_greater_than(0) \
                .with_options(test_name='input statement contains left paren')
            # verify there is some kind of quoted string in the input statement after the left paren
            if idx_left_paren >= 0:
                # assume the student uses double-quotes until proven otherwise
                type_of_quote = '"'
                idx_quote_start = student_code[idx_left_paren:].find('"')
                # might be using single quotes
                if idx_quote_start < 0:
                    idx_quote_start = student_code[idx_left_paren:].find("'")
                    if idx_quote_start >= 0:
                        type_of_quote = "'"
                expect(idx_quote_start).to_be_greater_than(0) \
                        .with_options(test_name='input statement contains a starting quote character')
                        
                # look for the matching ending quote
                if idx_quote_start >= 0:
                    idx_quote_end = student_code[idx_quote_start+1:].find(type_of_quote)
                    expect(idx_quote_end).to_be_greater_than(0) \
                        .with_options(test_name='input statement contains a matching ending quote character')
        
                # check for closing right paren at the end of the input statemtn
                if idx_quote_start > 0 and idx_quote_end > 0:
                    idx_right_paren = student_code[idx_quote_end:].find(')')
                    expect(idx_quote_end).to_be_greater_than(0) \
                        .with_options(test_name='input statement contains a matching right paren')
        


        #pass

    # Write any tests that should run after the code is evaluated
    def after_run(self, student_code, solution_code, student_output, solution_output):
        
        student_lower = student_output.lower()
        solution_lower = solution_output.lower()
        
        idx_hello = student_lower.find('hello,')
        expect(idx_hello).to_be_greater_than_or_equal_to(0) \
            .with_options(test_name='output contains hello, or Hello, ')
                

Suite()

# other viedo: https://www.youtube.com/watch?v=fKy9snQF6eM
# notes for Python 3 Autograders

# the before_run function can return none, or an object shaped like this:
# {'student_code': string, 'solution_code': string, 'inputs': list}
# these will replace the existing student_code and solution_code, 
# and the inputs will be extended on this suite's inputs

# using `ast`
# if you'd like to parse student code using the `ast` module, define a subclass of
# the ast.NodeVisitor class which will be used to traverse the code tree:
# class Visitor(ast.NodeVisitor):
#
#     def generic_visit(self, node):
#         ast.NodeVisitor.generic_visit(self, node)
#
#     def visit_NodeType(self, node):
#         # specific behavior...
#
#         self.generic_visit(node)

# then parse and traverse the code like this:
# visitor = Visitor()
# visitor.visit(ast.parse(student_code))

# the abstract grammar for the ast is defined here:
# https://docs.python.org/3.6/library/ast.html#abstract-grammar
# here's an example of a Visitor that will pull out the contents of
# a for loop:

# class ForLoopVisitor(ast.NodeVisitor):
#     for_loop_variable_name = ''
#     for_loop_range = []
#     def visit_For(self, node):
#         import pdb;pdb.set_trace()
#         if isinstance(node.target, ast.Name):
#             self.for_loop_variable_name = node.target.id
#         if isinstance(node.iter, ast.Call):
#             # extract the numerical value from the ast.Nums
#             self.for_loop_range = list(map(lambda num: num.n, node.iter.args))

# student_code = '\nfor x in range(10):\n  print(x)\n'
# v = ForLoopVisitor()
# v.visit(ast.parse(student_code))
# print('For loop iterating {} to {}'.format(v.for_loop_variable_name, v.for_loop_range))